
global:
  imageRegistry: ""    # We are using default registry here which it is docker.io
  imagePullSecrets: []  # We don't have a private registry so this will be empty
  defaultStorageClass: ""  # Will use cluster default
  storageClass: "" # Will use SSD storage classs

  security:
    allowInsecureImages: false  # We don't want unverified images to be installed so this would be set to false

  compatibility:
    openshift:
      adaptSecurityContext: disable  # We are not using openshift so this should be disable as well

kubeVersion: ""

nameOverride: ""

fullnameOverride: ""

namespaceOverride: ""

clusterDomain: cluster.local

commonAnnotations: {}

commonLabels: {}

extraDeploy: []

serviceBindings:
  enabled: false

diagnosticMode:
  enabled: false
  command:
    - sleep
  args:
    - infinity

image:
  registry: docker.io  # Mysql image registry
  repository: bitnami/mysql # Mysql image repository
  #tag: 9.3.0-debian-12-r2  # Image tag should be set to an immutable tag 
  tag: 8.0.39-debian-12-r0
  digest: "" # We don't wanto to override our tag so this should be empty
  pullPolicy: IfNotPresent

  ## pullSecrets:
  ##   - myRegistryKeySecretName
  ##
  pullSecrets: []  # We don't have any secrets or private registries so this parameter won't be useful

  debug: false # I would set it to true if more logs needed

architecture: replication # It's a master-slave architecture 

## MySQL Authentication parameters

auth:
  rootPassword: "" # Set your password here or use secrets if you configured (Consider it for other passwords as well)
  createDatabase: true
  database: "arvan_database"
  username: "arvan_user"
  password: ""
  replicationUser: secondary_user
  replicationPassword: ""
  existingSecret: "mysql-credentials" # The secret has to contain the keys `mysql-root-password`, `mysql-replication-password` and `mysql-password`
  usePasswordFiles: true
  customPasswordFiles: {} 
  authenticationPolicy: ""

initdbScripts: {} # Use if you need scripts to be run as first boot
initdbScriptsConfigMap: "" # Configmap for initdb scripts

startdbScripts: {} # Use if you need scripts to be run everytime the container is started
startdbScriptsConfigMap: "" # Configmap for startdb scripts

# Configuring TLS parameters
tls:
  enabled: false
  existingSecret: ""
  certFilename: tls.crt
  certKeyFilename: tls.key
  certCAFilename: ""
  ca: ""
  cert: ""
  key: ""

 # tls.autoGenerated.enabled Enable automatic generation of certificates for TLS
 # tls.autoGenerated.engine Mechanism to generate the certificates
  autoGenerated:
    enabled: true
    engine: helm
    certManager:
      existingIssuer: ""
      existingIssuerKind: ""
      keySize: 2048
      keyAlgorithm: RSA
      duration: 2160h
      renewBefore: 360h

## MySQL Primary parameters ##

primary:

  name: primary
  command: [] # Overriding default command of the container but we don't need it cause we are using bitnami image
  args: [] # Same as command but for args
  lifecycleHooks: {}  # Automate configuration before or after startup

  automountServiceAccountToken: false # We don't need any serviceAccountToken in the pod

  hostAliases: [] # Add entries to pod in /etc/hosts if needed

  enableMySQLX: false

  configuration: |-
    [mysqld]
    authentication_policy='{{- .Values.auth.authenticationPolicy | default "* ,," }}'
    skip-name-resolve
    explicit_defaults_for_timestamp

    # Performance Tuning 
    # innodb_buffer_pool_size=3G    # ~75% of available memory
    # innodb_log_file_size=1G
    # innodb_flush_log_at_trx_commit=1  # ACID compliance
    # innodb_flush_method=O_DIRECT

    # File Paths
    basedir=/opt/bitnami/mysql
    datadir=/bitnami/mysql/data
    socket=/opt/bitnami/mysql/tmp/mysql.sock
    plugin_dir=/opt/bitnami/mysql/lib/plugin
    pid-file=/opt/bitnami/mysql/tmp/mysqld.pid
    log-error=/opt/bitnami/mysql/logs/mysqld.log
    tmpdir=/opt/bitnami/mysql/tmp

    port={{ .Values.primary.containerPorts.mysql }}

    # MysqlX config
    mysqlx={{ ternary 1 0 .Values.primary.enableMySQLX }}
    mysqlx_port={{ .Values.primary.containerPorts.mysqlx }}

    # Connection Settings
    max_connections=500          # Increase connection limit
    max_allowed_packet=16M

    # Security
    bind-address=0.0.0.0
    
    character-set-server=UTF8

    # Monitoring
    slow_query_log=1      # Set to 1 to enable sloq query logs
    slow-query-log-file=/opt/bitnami/mysql/logs/mysql-slow.log
    long_query_time=2.0   # Log queries > 2 seconds

    # General log
    general-log=1
    general-log-file=/opt/bitnami/mysql/logs/mysql-general.log

    # TLS and SSL part
    {{- if .Values.tls.enabled }}
    ssl_cert=/opt/bitnami/mysql/certs/{{ .Values.tls.certFilename }}
    ssl_key=/opt/bitnami/mysql/certs/{{ .Values.tls.certKeyFilename }}
    {{- if (include "mysql.tlsCACert" .) }}
    ssl_ca={{ include "mysql.tlsCACert" . }}
    {{- end }}
    {{- end }}

    [client]
    port={{ .Values.primary.containerPorts.mysql }}
    socket=/opt/bitnami/mysql/tmp/mysql.sock
    default-character-set=UTF8
    plugin_dir=/opt/bitnami/mysql/lib/plugin

    [manager]
    port={{ .Values.primary.containerPorts.mysql }}
    socket=/opt/bitnami/mysql/tmp/mysql.sock
    pid-file=/opt/bitnami/mysql/tmp/mysqld.pid

  existingConfigmap: ""  # If we set values in it the configuration above will be ignored.

  containerPorts:
    mysql: 3306
    mysqlx: 33060

  updateStrategy:
    type: RollingUpdate

  podAnnotations: {}

  podAffinityPreset: ""

  podAntiAffinityPreset: soft

  nodeAffinityPreset:
    type: ""
    key: ""
    values: []

  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
          - matchExpressions:
              - key: node-role.kubernetes.io/cloud-container-g2
                operator: In
                values:
                  - "true"

  nodeSelector: {} # Node labels for pod assignment

  tolerations:
    - effect: NoSchedule
      key: role
      operator: Equal
      value: cloud-container-g2
 
  priorityClassName: ""

  runtimeClassName: ""

  schedulerName: "" # If we wanted to use another scheduler which we don't!

  terminationGracePeriodSeconds: ""  # Time the given to the MySQL primary pod needs to terminate gracefully

  topologySpreadConstraints: []

  podManagementPolicy: ""

  podSecurityContext:  # Security context for MySql master pod
    enabled: true
    fsGroupChangePolicy: Always # Set filesystem group change policy
    sysctls: [] # If we want to set sysctl kernel settings
    supplementalGroups: [] # Set filesystem extra groups
    fsGroup: 1001 # Group ID for the mounted volumes' filesystem

  #MySQL master container security context
  containerSecurityContext:
    enabled: true
    seLinuxOptions: {}
    runAsUser: 1001
    runAsGroup: 1001
    runAsNonRoot: true
    allowPrivilegeEscalation: false
    capabilities:
      drop: [ "ALL" ]
    seccompProfile:
      type: "RuntimeDefault"
    readOnlyRootFilesystem: true
  
  resourcesPreset: "medium"
  # Set container requests and limits for different resources like CPU or memory (essential for production workloads)
  resources:
    requests:
      cpu: "2"
      memory: "4Gi"
    limits:
      cpu: "4"
      memory: "8Gi"

  livenessProbe:
    enabled: false
    initialDelaySeconds: 5  # Initial delay seconds for livenessProbe
    periodSeconds: 10  # Period seconds for livenessProbe
    timeoutSeconds: 1  # Timeout seconds for livenessProbe
    failureThreshold: 3  # Failure threshold for livenessProbe
    successThreshold: 1  # Success threshold for livenessProbe

  readinessProbe:
    enabled: false
    initialDelaySeconds: 5  # Initial delay seconds for readinessProbe
    periodSeconds: 10  # Period seconds for readinessProbe
    timeoutSeconds: 1  # Timeout seconds for readinessProbe 
    failureThreshold: 3  # Failure threshold for readinessProbe
    successThreshold: 1  # Success threshold for readinessProbe

  startupProbe:
    enabled: false
    initialDelaySeconds: 15
    periodSeconds: 10
    timeoutSeconds: 1
    failureThreshold: 10
    successThreshold: 1

  customLivenessProbe: {}  # This will override the default one

  customReadinessProbe: {}  # This will override the default one

  customStartupProbe: {}  # This will override the default one

  extraFlags: ""  # Mysql master additional command flags

  extraEnvVars: []  # Extra env to be MySql master container

  extraEnvVarsCM: "" # Name of existing configmap containing extra env vars

  extraEnvVarsSecret: "" # Name of existing Secret containing extra env vars

  extraPodSpec: {}  # Optionally specify extra PodSpec for the MySQL Primary pod(s)
 
  extraPorts: []  # Extra Ports to expose

  persistence:
    enabled: true

    existingClaim: ""  # Name of an existing PVC and if we set it the of persistense parameters are ignored

    subPath: ""  # Name of a volume's sub path to mount for persistence

    storageClass: ""

    annotations: {} # Annotations for PVC

    accessModes:
      - ReadWriteOnce

    size: 20Gi

    selector: {}  # Selector to match an existing PV

  persistentVolumeClaimRetentionPolicy:
    # Enable Persistent volume retention policy for Primary StatefulSet
    enabled: false

    # Volume retention behavior when the replica count of the StatefulSet is reduced
    whenScaled: Retain

    # Volume retention behavior that applies when the StatefulSet is deleted
    whenDeleted: Retain

  extraVolumes: [] # Extra list of additional volume to the master pod

  extraVolumeMounts: [] # Extra list of additional volumeMounts to the master pod

  initContainers: [] 

  sidecars: []
    # - name: filebeat
    #   image: docker.elastic.co/beats/filebeat:8.6.2
    #   args:
    #     - "-c"
    #     - "/etc/filebeat.yml"
    #     - "-e"
    #   volumeMounts:
    #     - name: filebeat-config
    #       mountPath: /etc/filebeat.yml
    #       subPath: filebeat.yml
    #     - name: mysql-logs
    #       mountPath: /opt/bitnami/mysql/logs
    #       readOnly: true
    #   resources:
    #     limits:
    #       memory: 200Mi
    #       cpu: 100m
    #     requests:
    #       memory: 100Mi
    #       cpu: 50m

  # Extra volumes
  # extraVolumes:
  #   - name: filebeat-config
  #     configMap:
  #       name: filebeat-config
  #   - name: mysql-logs
  #     emptyDir: {}

  # Mount logs directory to MySQL container
  # extraVolumeMounts:
  #   - name: mysql-logs
  #     mountPath: /opt/bitnami/mysql/logs

  service:
    type: ClusterIP
    ports:
      mysql: 3306
      mysqlx: 33060

    nodePorts:
      mysql: ""
      mysqlx: ""

    clusterIP: ""

    loadBalancerIP: ""

    externalIPs: []
 
    externalTrafficPolicy: Cluster

    loadBalancerSourceRanges: []

    extraPorts: [] # Use it with the sidecar value
 
    annotations: {} # Annotation for mysql-master service

    sessionAffinity: None

    sessionAffinityConfig: {} # For example set timeout for clientIP session affinity

    headless:
      annotations: {}

  pdb:
    create: false
    minAvailable: ""
    maxUnavailable: ""

  podLabels: {}

# MySQL Slave parameters

secondary:

  name: secondary

  replicaCount: 1

  automountServiceAccountToken: false

  hostAliases: []

  command: []

  args: []

  lifecycleHooks: {}

  enableMySQLX: false

  configuration: |-
    [mysqld]
    server-id=2                       # Unique ID (increment for each replica)
    read_only=1                       # Make slave read-only
    authentication_policy='{{- .Values.auth.authenticationPolicy | default "* ,," }}'
    skip-name-resolve
    explicit_defaults_for_timestamp

    # Performance Tuning 
    # innodb_buffer_pool_size=3G    # ~75% of available memory
    # innodb_log_file_size=1G
    # innodb_flush_log_at_trx_commit=1  # ACID compliance
    # innodb_flush_method=O_DIRECT

    # File Paths
    basedir=/opt/bitnami/mysql
    datadir=/bitnami/mysql/data
    socket=/opt/bitnami/mysql/tmp/mysql.sock
    plugin_dir=/opt/bitnami/mysql/lib/plugin
    pid-file=/opt/bitnami/mysql/tmp/mysqld.pid
    log-error=/opt/bitnami/mysql/logs/mysqld.log
    tmpdir=/opt/bitnami/mysql/tmp

    port={{ .Values.secondary.containerPorts.mysql }}

    # MysqlX config
    mysqlx={{ ternary 1 0 .Values.secondary.enableMySQLX }}
    mysqlx_port={{ .Values.secondary.containerPorts.mysqlx }}

    max_allowed_packet=16M

    # Security
    bind-address=*
    
    character-set-server=UTF8

    # Monitoring
    slow_query_log=1      # Set to 1 to enable sloq query logs
    long_query_time=2.0   # Log queries > 2 seconds

    # TLS and SSL part
    {{- if .Values.tls.enabled }}
    ssl_cert=/opt/bitnami/mysql/certs/{{ .Values.tls.certFilename }}
    ssl_key=/opt/bitnami/mysql/certs/{{ .Values.tls.certKeyFilename }}
    {{- if (include "mysql.tlsCACert" .) }}
    ssl_ca={{ include "mysql.tlsCACert" . }}
    {{- end }}
    {{- end }}

    [client]
    port={{ .Values.secondary.containerPorts.mysql }}
    socket=/opt/bitnami/mysql/tmp/mysql.sock
    default-character-set=UTF8
    plugin_dir=/opt/bitnami/mysql/lib/plugin

    [manager]
    port={{ .Values.secondary.containerPorts.mysql }}
    socket=/opt/bitnami/mysql/tmp/mysql.sock
    pid-file=/opt/bitnami/mysql/tmp/mysqld.pid

  existingConfigmap: ""

  containerPorts:
    mysql: 3306
    mysqlx: 33060

  updateStrategy:
    type: RollingUpdate

  podAnnotations: {}

  podAffinityPreset: ""

  podAntiAffinityPreset: soft

  nodeAffinityPreset:
    type: ""
    key: ""
    values: []

  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
          - matchExpressions:
              - key: node-role.kubernetes.io/cloud-container-g2
                operator: In
                values:
                  - "true"

  nodeSelector: {}

  tolerations:
    - effect: NoSchedule
      key: role
      operator: Equal
      value: cloud-container-g2

  priorityClassName: ""
 
  runtimeClassName: ""

  schedulerName: ""

  terminationGracePeriodSeconds: ""

  topologySpreadConstraints: []

  podManagementPolicy: ""

  podSecurityContext:
    enabled: true
    fsGroupChangePolicy: Always
    sysctls: []
    supplementalGroups: []
    fsGroup: 1001

  containerSecurityContext:
    enabled: true
    seLinuxOptions: {}
    runAsUser: 1001
    runAsGroup: 1001
    runAsNonRoot: true
    allowPrivilegeEscalation: false
    capabilities:
      drop: [ "ALL" ]
    seccompProfile:
      type: "RuntimeDefault"
    readOnlyRootFilesystem: true

  resourcesPreset: "medium"
  resources:
    requests:
      cpu: "2"
      memory: "4Gi"
    limits:
      cpu: "4"
      memory: "8Gi"
  
  livenessProbe:
    enabled: true
    initialDelaySeconds: 30
    periodSeconds: 30
    timeoutSeconds: 5 
    failureThreshold: 3
    successThreshold: 1

  readinessProbe:
    enabled: true
    initialDelaySeconds: 5
    periodSeconds: 10
    timeoutSeconds: 1
    failureThreshold: 3
    successThreshold: 1

  startupProbe:
    enabled: true
    initialDelaySeconds: 15
    periodSeconds: 10
    timeoutSeconds: 1
    failureThreshold: 30
    successThreshold: 1

  customLivenessProbe: {}

  customReadinessProbe: {}

  customStartupProbe: {}

  extraFlags: ""

  extraEnvVars: []

  extraEnvVarsCM: ""

  extraEnvVarsSecret: ""

  extraPodSpec: {}

  extraPorts: []

  persistence:
    enabled: true

    existingClaim: ""

    subPath: ""

    storageClass: ""

    annotations: {}

    accessModes:
      - ReadWriteOnce

    size: 20Gi

    selector: {}

  persistentVolumeClaimRetentionPolicy:
    enabled: false
    whenScaled: Retain
    whenDeleted: Retain

  extraVolumes: []

  extraVolumeMounts: []

  initContainers: []

  sidecars: []

  service:
    type: ClusterIP
    ports:
      mysql: 3306
      mysqlx: 33060

    nodePorts:
      mysql: ""
      mysqlx: ""

    clusterIP: ""

    loadBalancerIP: ""

    externalIPs: []

    externalTrafficPolicy: Cluster

    loadBalancerSourceRanges: []

    extraPorts: []

    annotations: {}

    sessionAffinity: None

    sessionAffinityConfig: {}

    headless:

      annotations: {}

  pdb:
    create: false
    minAvailable: ""
    maxUnavailable: ""

  podLabels: {}

serviceAccount:
  create: true
  annotations: {}
  automountServiceAccountToken: false

rbac:

  create: false

  rules: []

networkPolicy:

  enabled: false

  allowExternal: true  # If you set this to false only pods with correct client label have network access if no mysql will accecpt connections from any source

  allowExternalEgress: true  # Allows the pod to access any range of ports and all destinations
  # Add extra ingress rules to the NetworkPolicy
  ## e.g:
  ## extraIngress:
  ##   - ports:
  ##       - port: 1234
  ##     from:
  ##       - podSelector:
  ##           - matchLabels:
  ##               - role: frontend
  ##       - podSelector:
  ##           - matchExpressions:
  ##               - key: role
  ##                 operator: In
  ##                 values:
  ##                   - frontend
  ##
  extraIngress: []
  # Add extra ingress rules to the NetworkPolicy
  ## e.g:
  ## extraEgress:
  ##   - ports:
  ##       - port: 1234
  ##     to:
  ##       - podSelector:
  ##           - matchLabels:
  ##               - role: frontend
  ##       - podSelector:
  ##           - matchExpressions:
  ##               - key: role
  ##                 operator: In
  ##                 values:
  ##                   - frontend
  ##
  extraEgress: []

  ingressNSMatchLabels: {} # Labels to match to allow traffic from other namespaces
  ingressNSPodMatchLabels: {} # Pod labels to match to allow traffic from other namespaces

#Password update job

passwordUpdateJob:

  enabled: false

  backoffLimit: 10

  command: []

  args: []

  extraCommands: ""

  previousPasswords:
    rootPassword: ""
    password: ""
    replicationPassword: ""
    existingSecret: ""

  containerSecurityContext:
    enabled: true
    seLinuxOptions: {}
    runAsUser: 1001
    runAsGroup: 1001
    runAsNonRoot: true
    privileged: false
    readOnlyRootFilesystem: true
    allowPrivilegeEscalation: false
    capabilities:
      drop: [ "ALL" ]
    seccompProfile:
      type: "RuntimeDefault"

  podSecurityContext:
    enabled: true
    fsGroupChangePolicy: Always
    sysctls: []
    supplementalGroups: []
    fsGroup: 1001

  extraEnvVars: []

  extraEnvVarsCM: ""

  extraEnvVarsSecret: ""

  extraVolumes: []

  extraVolumeMounts: []

  initContainers: []

  resourcesPreset: "medium"

  resources: {}

  customLivenessProbe: {}

  customReadinessProbe: {}

  customStartupProbe: {}

  automountServiceAccountToken: false

  hostAliases: []

  annotations: {}

  podLabels: {}

  podAnnotations: {}



volumePermissions:

  enabled: false

  image:
    registry: docker.io
    repository: bitnami/os-shell
    tag: 12-debian-12-r46
    digest: ""
    pullPolicy: IfNotPresent

    pullSecrets: []

  resourcesPreset: "medium"

  resources: {}

metrics:
  # Start a side-car prometheus exporter
  enabled: true

  image:
    registry: docker.io
    repository: bitnami/mysqld-exporter
    tag: 0.17.2-debian-12-r12
    digest: ""
    pullPolicy: IfNotPresent

    pullSecrets: []

  containerSecurityContext:
    enabled: true
    seLinuxOptions: {}
    runAsUser: 1001
    runAsGroup: 1001
    runAsNonRoot: true
    allowPrivilegeEscalation: false
    capabilities:
      drop: [ "ALL" ]
    seccompProfile:
      type: "RuntimeDefault"
    readOnlyRootFilesystem: true

  containerPorts:
    http: 9104
  ## MySQL Prometheus exporter service parameters
  ## Mysqld Prometheus exporter liveness and readiness probes
  ## ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
  ## @param metrics.service.type Kubernetes service type for MySQL Prometheus Exporter
  ## @param metrics.service.clusterIP Kubernetes service clusterIP for MySQL Prometheus Exporter
  ## @param metrics.service.port MySQL Prometheus Exporter service port
  ## @param metrics.service.annotations [object] Prometheus exporter service annotations
  ##
  service:
    type: ClusterIP
    port: 9104
    clusterIP: ""
    annotations:
      prometheus.io/scrape: "true"
      prometheus.io/port: "{{ .Values.metrics.service.port }}"
  # Extra args to be passed to mysqld_exporter on Primary pods
  # Extra args to be passed to mysqld_exporter on Secondary pods
  ## ref: https://github.com/prometheus/mysqld_exporter/
  ## E.g.
  ## - --collect.auto_increment.columns
  ## - --collect.binlog_size
  ## - --collect.engine_innodb_status
  ## - --collect.engine_tokudb_status
  ## - --collect.global_status
  ## - --collect.global_variables
  ## - --collect.info_schema.clientstats
  ## - --collect.info_schema.innodb_metrics
  ## - --collect.info_schema.innodb_tablespaces
  ## - --collect.info_schema.innodb_cmp
  ## - --collect.info_schema.innodb_cmpmem
  ## - --collect.info_schema.processlist
  ## - --collect.info_schema.processlist.min_time
  ## - --collect.info_schema.query_response_time
  ## - --collect.info_schema.tables
  ## - --collect.info_schema.tables.databases
  ## - --collect.info_schema.tablestats
  ## - --collect.info_schema.userstats
  ## - --collect.perf_schema.eventsstatements
  ## - --collect.perf_schema.eventsstatements.digest_text_limit
  ## - --collect.perf_schema.eventsstatements.limit
  ## - --collect.perf_schema.eventsstatements.timelimit
  ## - --collect.perf_schema.eventswaits
  ## - --collect.perf_schema.file_events
  ## - --collect.perf_schema.file_instances
  ## - --collect.perf_schema.indexiowaits
  ## - --collect.perf_schema.tableiowaits
  ## - --collect.perf_schema.tablelocks
  ## - --collect.perf_schema.replication_group_member_stats
  ## - --collect.slave_status
  ## - --collect.slave_hosts
  ## - --collect.heartbeat
  ## - --collect.heartbeat.database
  ## - --collect.heartbeat.table
  ##
  extraArgs:
    primary:
      - --collect.auto_increment.columns
      - --collect.binlog_size
      - --collect.engine_innodb_status
      - --collect.global_status
      - --collect.global_variables
      - --collect.info_schema.innodb_metrics
      - --collect.info_schema.processlist
      - --collect.info_schema.tables
      - --collect.perf_schema.eventsstatements
      - --collect.perf_schema.file_events
      - --collect.slave_status
    secondary:
      - --collect.slave_status          # Important for replica monitoring
      - --collect.global_status
      - --collect.engine_innodb_status
      

  resourcesPreset: "medium"
  # Set container requests and limits for different resources like CPU or memory (essential for production workloads)
  ## Example:
  ## resources:
  ##   requests:
  ##     cpu: 2
  ##     memory: 512Mi
  ##   limits:
  ##     cpu: 3
  ##     memory: 1024Mi
  ##
  resources: {}

  livenessProbe:
    enabled: false
    initialDelaySeconds: 120
    periodSeconds: 10
    timeoutSeconds: 1
    successThreshold: 1
    failureThreshold: 3

  readinessProbe:
    enabled: false
    initialDelaySeconds: 30
    periodSeconds: 10
    timeoutSeconds: 1
    successThreshold: 1
    failureThreshold: 3

  # Prometheus Service Monitor
  serviceMonitor:
    enabled: true  # ServiceMonitor Resource for scraping metrics using PrometheusOperator

    namespace: ""   # Specify the namespace in which the serviceMonitor resource will be created

    jobLabel: ""  # Name of the label on the target service to use as the job name

    interval: 30s  # The interval for scraping metrics

    scrapeTimeout: ""  # Timeout for ending the scraping

    relabelings: []

    metricRelabelings: []
    ## selector:
    ##   prometheus: my-prometheus
    selector: {}  # ServiceMonitor selector labels

    honorLabels: false

    labels: 
      app: mysql
      environment: production

    annotations: {}

  prometheusRule:
    # For Alerting
    enabled: true

    namespace: ""

    additionalLabels: {}
    ## @param metrics.prometheusRule.rules Prometheus Rule definitions
    ##  - alert: Mysql-Down
    ##    expr: absent(up{job="mysql"} == 1)
    ##    for: 5m
    ##    labels:
    ##      severity: warning
    ##      service: mysql
    ##    annotations:
    ##      message: 'mysql instance {{`{{`}} $labels.instance {{`}}`}}  is down'
    ##      summary: mysql instance is down
    ##
    rules:
      - alert: MySQLDown
        expr: mysql_up == 0
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "MySQL instance is down"
          
      - alert: MySQLReplicationLag
        expr: mysql_slave_lag_seconds > 300
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "MySQL replication lag is high"
          
      - alert: MySQLHighConnections
        expr: mysql_global_status_threads_connected / mysql_global_variables_max_connections > 0.8
        for: 10m
        labels:
          severity: warning
        annotations:
          summary: "MySQL connection usage is high"

      - alert: MySQLReplicationIOisDown
        expr: mysql_slave_status_slave_io_running == 0
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "MySQL replication I/O thread is down"

